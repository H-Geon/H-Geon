# -*- coding: utf-8 -*-
"""Pandas 공부2

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15OV2IcmG4ftwg-OqpdXtGo1VLg32-vB8
"""

#판다스 공부 2
import pandas as pd
#원본 파일 로딩
titanic_df=pd.read_csv('/content/drive/MyDrive/하기싫다/train.csv')
#Index 객체 추출
indexes=titanic_df.index
print(indexes)
#Index 객체를 실제 값 array로 변환
print('Index 객체 array값:\n',indexes.values)
#Index객체는 식별성 데이터를 1차원 array로 가지고 있음.

#단일값 반환 및 슬라이싱 가능
print(type(indexes.values))
print(indexes.values.shape)
print(indexes[:5].values)
print(indexes.values[:5])
print(indexes[6])

#한 번 만들어진 DataFrame 및 Series의 Index 객체는 함부로 변경 불가능
indexes[0]=5 #오류 발생

#Series 객체는 Index 객체를 포함하지만 Series 객체에 연산함수를 적용할 때 Index는 연산에서 제외됨 오로지 식별용
series_fair=titanic_df['Fare']
print('Fair Series max 값:',series_fair.max())
print('Fair Series sum 값:',series_fair.sum())
print('sum() Fair Series:',sum(series_fair))
print('Fair Series+3:\n',(series_fair+3).head(3))

#DataFrame 및 Series에 reset_index() 메서드를 수행하면 새롭게 인덱스를 연속 숫자 형으로 할당 가능
titanic_reset_df=titanic_df.reset_index(inplace=False)
titanic_reset_df.head(3)

#Series에 reset_index()를 적용하면 Series가 아닌 DataFrame이 반환됨
print('###before reset_index ###')
value_counts=titanic_df['Pclass'].value_counts()
print(value_counts)
print('value_counts 객체 변수 타입:',type(value_counts))
new_value_counts=value_counts.reset_index(inplace=False)
print('### After reset_index ###')
print(new_value_counts)
print('new_value_counts 객체 변수 타입:',type(new_value_counts))

"""Series에 reset_index()를 적용하면 새롭게 연속 숫자형 인덱스가 만들어지고 기존 인덱스는
 'index'칼럼명으로 추가되면서 Dataframe 으로 변환됨

"""

#데이터 셀렉션 및 필터링

#판다스와 넘파이의 []연산자가 어떤 차이가 있는가?

"""넘파이에서 []연산자는 행의 위치, 열의 위치,슬라이싱 범위 등을 지정해 데이터를 가져올 수 있었음
하지만 DataFrame 바로 뒤에 있는 '[]'안에 들어갈 수 있는 것은 칼럼 명 문자,또는 인덱스로 변환 가능한 표현식임.

"""

print('단일 칼럼 데이터 추출:\n',titanic_df['Pclass'].head(3))
print('\n여러 칼럼의 데이터 추출:\n',titanic_df[['Survived','Pclass']].head(3))
print('[]안에 숫자 index는 Keyerror 오류 발생:\n',titanic_df[0])

#but 판다스의 인덱스 형태로 변환 가능한 표현식은 입력 가능
titanic_df[0:2]
#또 불린인덱싱 표현도 가능
titanic_df[titanic_df['Pclass']==3].head(3)

"""###정리
####DataFrame 바로 뒤의 []연산자는 넘파이의 []나 series의 []와 다르다.
####DataFrame 바로 뒤의 [] 내 입력 값은 칼럼명 (또는 칼럼의 리스트)을 지정해 칼럼 지정연산에 사용하거나 불린 인덱스 용도로만 사용해야함
####DataFrame[0:2]와 같은 슬라이싱 연산으로 데이터를 추출하는 방법은 사용하지 않는게 좋음

"""

#DataFrame ix[] 연산자를 공부하려던 중 책에서 곧 사라질 예정이라고 해서 건너 띔

"""명칭기반 인덱싱과 위치 기반 인덱싱의 구분
===================================================
*  명칭(Label) 기반 인덱싱은 칼럼의 명칭을 기반으로 위치를 지정하는 방식
*  위치 기반 인덱싱은 0을 출발점으로 하는 가로축, 세로축 좌표 기반의 행과 열 위치를 기반으로 데이터를 지정
> DataFrame의 인덱스값은 명칭기반 인덱싱임.

"""

#DataFrame iloc[]연산자(위치 기반)
data= {'Name':['chulmin','Eunkyung','Jinwoong','Soobeom'],
       'Year':[2011,2016,2015,2015],
       'Gender':['male','Female','Male','Male']}
data_df=pd.DataFrame(data,index=['one','two','three','four'])
data_df

data_df.iloc[0,0]
#iloc[]에 위치 인덱싱이 아닌 명칭을 입력하면 오류 발생

#DataFrame loc[] 연산자는 명칭기반임 그치만 index가 숫자형일수 있기 때문에 무조건 문자열로 하지 않아도 됨

data_df.loc['one','Name']

#loc[]에 슬라이싱 기호 (:) 사용할 때 시작값:종료값-1이 아님. 이는 명칭기반이기 때문
print('명칭 기반 loc slicing\n',data_df.loc['one':'two','Name'],'\n')
print('위치 기반 iloc slicing\n',data_df.iloc[0:1,0],'\n')

"""정리
------------------
* 가장 중요한 것은 명칭 기반 인덱싱과 위치 기반 인덱싱의 차이를 이해하는 것, DataFrame의 인덱스나 칼럼명으로 데이터에 접근하는 것은 명칭 기반 인덱싱임. 0부터 시작하는 행, 열의 위치 좌표에만 의존하는 것이 위치 기반 인덱싱

* iloc[]는 위치 기반 인덱싱만 가능. 따라서 행과 열 위치 값으로 정수형 값을 지정해 원하는 데이터를 반환.

* loc[]는 명칭 기반 인덱싱만 가능. 따라서 행 위치에 DataFrame 인덱스가 오며, 열 위치에는 칼럼 명을 지정해 원하는 데이터 반환

* 명칭기반 인덱싱에서 슬라이싱을 '시작점:종료점'으로 지정할 때 시작점에서 종료점을 포함한위치에 있는 데이터를 반환함

****************

불린인덱싱
------------------
*loc[]에서 지원함. 위치기반 iloc[]에선 불린 값에 대해서는 지원하지 않음.
"""

titanic_df=pd.read_csv('/content/drive/MyDrive/하기싫다/train.csv')
titanic_boolean=titanic_df[titanic_df['Age']>60]
print(type(titanic_boolean))
titanic_boolean

titanic_df[titanic_df['Age']>60][['Name','Age']].head(3)

titanic_df.loc[titanic_df['Age']>60,['Name',"Age"]].head(3)

"""* and는 &
* or는 |
* Not은 ~
"""

titanic_df[(titanic_df['Age']>60)&(titanic_df['Pclass']==1)&
           (titanic_df['Sex']=='female')]

cond1=titanic_df['Age']>60
cond2=titanic_df['Pclass']==1
cond3=titanic_df['Sex']=='female'
titanic_df[cond1&cond2&cond3]